/* Copyright 2024 Joachim Metz <joachim.metz@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may
 * obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

//! LZFSE decompression.
//!
//! Provides decompression support for LZFSE compressed data.

use std::cmp;
use std::io;

use layout_map::LayoutMap;

use crate::mediator::{Mediator, MediatorReference};
use crate::{bytes_to_i32_le, bytes_to_u16_le, bytes_to_u32_le, bytes_to_u64_le};

use super::lzvn::LzvnContext;
use super::traits::Bitstream;

const LZFSE_END_OF_STREAM_BLOCK_MARKER: u32 = 0x24787662;
const LZFSE_UNCOMPRESSED_BLOCK_MARKER: u32 = 0x2d787662;
const LZFSE_COMPRESSED_BLOCK_V1_MARKER: u32 = 0x31787662;
const LZFSE_COMPRESSED_BLOCK_V2_MARKER: u32 = 0x32787662;
const LZFSE_COMPRESSED_BLOCK_LZVN_MARKER: u32 = 0x6e787662;

const LZFSE_NUMBER_OF_LITERAL_STATES: i16 = 1024;
const LZFSE_NUMBER_OF_LITERAL_SYMBOLS: i16 = 256;

const LZFSE_NUMBER_OF_L_VALUE_STATES: i16 = 64;
const LZFSE_NUMBER_OF_L_VALUE_SYMBOLS: i16 = 20;

const LZFSE_NUMBER_OF_M_VALUE_STATES: i16 = 64;
const LZFSE_NUMBER_OF_M_VALUE_SYMBOLS: i16 = 20;

const LZFSE_NUMBER_OF_D_VALUE_STATES: i16 = 256;
const LZFSE_NUMBER_OF_D_VALUE_SYMBOLS: i16 = 64;

// const LZFSE_MATCHES_PER_BLOCK: usize = 10000;
// const LZFSE_LITERALS_PER_BLOCK: usize = 40000; // 4 * LZFSE_MATCHES_PER_BLOCK;
const LZFSE_MAXIMUM_NUMBER_OF_LITERALS: usize = 40064; // LZFSE_LITERALS_PER_BLOCK + 64

const LZFSE_FREQUENCY_NUMBER_OF_BITS_TABLE: [u8; 32] = [
    2, 3, 2, 5, 2, 3, 2, 8, 2, 3, 2, 5, 2, 3, 2, 14, 2, 3, 2, 5, 2, 3, 2, 8, 2, 3, 2, 5, 2, 3, 2,
    14,
];

const LZFSE_FREQUENCY_VALUE_TABLE: [u16; 32] = [
    0, 2, 1, 4, 0, 3, 1, 0xffff, 0, 2, 1, 5, 0, 3, 1, 0xffff, 0, 2, 1, 6, 0, 3, 1, 0xffff, 0, 2, 1,
    7, 0, 3, 1, 0xffff,
];

const LZFSE_D_VALUE_BITS_TABLE: [u8; 64] = [
    0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7,
    8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14,
    14, 14, 15, 15, 15, 15,
];

const LZFSE_D_VALUE_BASE_TABLE: [i32; 64] = [
    0, 1, 2, 3, 4, 6, 8, 10, 12, 16, 20, 24, 28, 36, 44, 52, 60, 76, 92, 108, 124, 156, 188, 220,
    252, 316, 380, 444, 508, 636, 764, 892, 1020, 1276, 1532, 1788, 2044, 2556, 3068, 3580, 4092,
    5116, 6140, 7164, 8188, 10236, 12284, 14332, 16380, 20476, 24572, 28668, 32764, 40956, 49148,
    57340, 65532, 81916, 98300, 114684, 131068, 163836, 196604, 229372,
];

const LZFSE_L_VALUE_BITS_TABLE: [u8; 20] =
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 5, 8];

const LZFSE_L_VALUE_BASE_TABLE: [i32; 20] = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 20, 28, 60,
];

const LZFSE_M_VALUE_BITS_TABLE: [u8; 20] =
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 5, 8, 11];

const LZFSE_M_VALUE_BASE_TABLE: [i32; 20] = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 24, 56, 312,
];

/// Bitstream for LZFSE compressed data.
pub(super) struct LzfseBitstream<'a> {
    /// Byte steam.
    data: &'a [u8],

    /// Current offset in the byte stream.
    pub data_offset: usize,

    /// Size of the byte stream in bytes.
    pub data_size: usize,

    /// Bits buffer.
    bits: u32,

    /// Number of bits in the bits buffer.
    pub number_of_bits: usize,
}

impl<'a> LzfseBitstream<'a> {
    /// Creates a new bitstream.
    pub fn new(data: &'a [u8], data_offset: usize) -> Self {
        let data_size: usize = data.len();
        Self {
            data: data,
            data_offset: data_offset,
            data_size: data_size,
            bits: 0,
            number_of_bits: 0,
        }
    }

    /// Reads input data backwards into the bits buffer in big-endian byte order.
    #[inline(always)]
    fn read_data(&mut self, number_of_bits: usize) {
        while number_of_bits > self.number_of_bits && self.number_of_bits <= 24 {
            self.data_offset -= 1;

            self.bits = (self.bits << 8) | self.data[self.data_offset] as u32;
            self.number_of_bits += 8;
        }
    }
}

impl<'a> Bitstream for LzfseBitstream<'a> {
    /// Retrieves a bit value.
    fn get_value(&mut self, number_of_bits: usize) -> u32 {
        let mut bit_offset: usize = 0;
        let mut value_32bit: u32 = 0;

        // Note that this does not check if number_of_bits <= 32
        while bit_offset < number_of_bits {
            let mut read_size: usize = number_of_bits - bit_offset;

            self.read_data(read_size);

            if read_size > self.number_of_bits {
                read_size = self.number_of_bits;
            }
            let mut read_value: u32 = self.bits;

            self.number_of_bits -= read_size;
            read_value >>= self.number_of_bits;

            if self.number_of_bits == 0 {
                self.bits = 0;
            } else {
                self.bits &= 0xffffffff >> (32 - self.number_of_bits);
            }
            if bit_offset > 0 {
                value_32bit <<= read_size;
            }
            value_32bit |= read_value;
            bit_offset += read_size;
        }
        value_32bit
    }

    /// Skips a number of bits.
    fn skip_bits(&mut self, mut number_of_bits: usize) {
        // Note that this does not check if number_of_bits <= 32
        while number_of_bits > 0 {
            self.read_data(number_of_bits);

            let mut read_size: usize = number_of_bits;

            if read_size > self.number_of_bits {
                read_size = self.number_of_bits;
            }
            self.number_of_bits -= read_size;

            if self.number_of_bits > 0 {
                self.bits &= 0xffffffff >> (32 - self.number_of_bits);
            }
            number_of_bits -= read_size;
        }
    }
}

#[derive(LayoutMap)]
#[layout_map(
    structure(
        byte_order = "little",
        field(name = "compressed_block_size", data_type = "u32"),
        field(name = "number_of_literals", data_type = "u32"),
        field(name = "number_of_lmd_values", data_type = "u32"),
        field(name = "literals_data_size", data_type = "u32"),
        field(name = "lmd_values_data_size", data_type = "u32"),
        field(name = "literal_bits", data_type = "i32"),
        field(name = "literal_states", data_type = "[u16; 4]"),
        field(name = "lmd_values_bits", data_type = "i32"),
        field(name = "l_value_state", data_type = "u16"),
        field(name = "m_value_state", data_type = "u16"),
        field(name = "d_value_state", data_type = "u16"),
    ),
    method(name = "debug_read_data")
)]
/// LZFSE version 1 block header.
struct LzfseBlockV1Header {}

impl LzfseBlockV1Header {
    /// Creates a new block header.
    pub fn new() -> Self {
        Self {}
    }

    /// Reads the block header from a buffer.
    pub fn read_data(&mut self, data: &[u8], decoder: &mut LzfseDecoder) -> io::Result<()> {
        if data.len() != 42 {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!("Unsupported data size"),
            ));
        }
        decoder.number_of_literals = bytes_to_u32_le!(data, 4);
        decoder.number_of_lmd_values = bytes_to_u32_le!(data, 8);
        decoder.literals_data_size = bytes_to_u32_le!(data, 12);
        decoder.lmd_values_data_size = bytes_to_u32_le!(data, 16);
        decoder.literal_bits = bytes_to_i32_le!(data, 20);

        let mut data_offset: usize = 24;
        for literal_state_index in 0..4 {
            decoder.literal_states[literal_state_index] = bytes_to_u16_le!(data, data_offset);
            data_offset += 2;
        }
        decoder.lmd_values_bits = bytes_to_i32_le!(data, 32);
        decoder.l_value_state = bytes_to_u16_le!(data, 36);
        decoder.m_value_state = bytes_to_u16_le!(data, 38);
        decoder.d_value_state = bytes_to_u16_le!(data, 40);

        Ok(())
    }
}

#[derive(LayoutMap)]
#[layout_map(
    structure(
        byte_order = "little",
        field(name = "number_of_literals", data_type = "BitField64<20>"),
        field(name = "literals_data_size", data_type = "BitField64<20>"),
        field(name = "number_of_lmd_values", data_type = "BitField64<20>"),
        field(name = "literal_bits", data_type = "BitField64<3>", modifier = "- 7"),
        field(name = "unknown1", data_type = "BitField64<1>"),
        field(name = "literal_state1", data_type = "BitField64<10>"),
        field(name = "literal_state2", data_type = "BitField64<10>"),
        field(name = "literal_state3", data_type = "BitField64<10>"),
        field(name = "literal_state4", data_type = "BitField64<10>"),
        field(name = "lmd_values_data_size", data_type = "BitField64<20>"),
        field(
            name = "lmd_values_bits",
            data_type = "BitField64<3>",
            modifier = "- 7"
        ),
        field(name = "unknown2", data_type = "BitField64<1>"),
        field(name = "header_size", data_type = "BitField64<32>"),
        field(name = "l_value_state", data_type = "BitField64<10>"),
        field(name = "m_value_state", data_type = "BitField64<10>"),
        field(name = "d_value_state", data_type = "BitField64<10>"),
        field(name = "unknown3", data_type = "BitField64<2>"),
    ),
    method(name = "debug_read_data")
)]
/// LZFSE version 2 block header.
struct LzfseBlockV2Header {
    header_size: u32,
}

impl LzfseBlockV2Header {
    /// Creates a new block header.
    pub fn new() -> Self {
        Self { header_size: 0 }
    }

    /// Reads the block header from a buffer.
    pub fn read_data(&mut self, data: &[u8], decoder: &mut LzfseDecoder) -> io::Result<()> {
        if data.len() < 24 {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!("Unsupported data size"),
            ));
        }
        let bit_fields1: u64 = bytes_to_u64_le!(data, 0);
        let bit_fields2: u64 = bytes_to_u64_le!(data, 8);
        let bit_fields3: u64 = bytes_to_u64_le!(data, 16);

        self.header_size = (bit_fields3 & 0xffffffff) as u32;

        decoder.number_of_literals = (bit_fields1 & 0x000fffff) as u32;
        decoder.literals_data_size = ((bit_fields1 >> 20) & 0x000fffff) as u32;
        decoder.number_of_lmd_values = ((bit_fields1 >> 40) & 0x000fffff) as u32;
        decoder.literal_bits = (((bit_fields1 >> 60) & 0x00000007) as i32) - 7;

        decoder.literal_states[0] = (bit_fields2 & 0x000003ff) as u16;
        decoder.literal_states[1] = ((bit_fields2 >> 10) & 0x000003ff) as u16;
        decoder.literal_states[2] = ((bit_fields2 >> 20) & 0x000003ff) as u16;
        decoder.literal_states[3] = ((bit_fields2 >> 30) & 0x000003ff) as u16;
        decoder.lmd_values_data_size = ((bit_fields2 >> 40) & 0x000fffff) as u32;
        decoder.lmd_values_bits = (((bit_fields2 >> 60) & 0x00000007) as i32) - 7;

        decoder.l_value_state = ((bit_fields3 >> 32) & 0x000003ff) as u16;
        decoder.m_value_state = ((bit_fields3 >> 42) & 0x000003ff) as u16;
        decoder.d_value_state = ((bit_fields3 >> 52) & 0x000003ff) as u16;

        if self.header_size < 32 || self.header_size > 720 {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!(
                    "Invalid header size: {} value out of bounds",
                    self.header_size
                ),
            ));
        }
        Ok(())
    }
}

/// Decoder entry for decompressing LZFSE compressed data.
struct LzfseDecoderEntry {
    /// The number of bits.
    pub number_of_bits: i8,

    /// The symbol.
    pub symbol: u8,

    /// The delta to compute the next state.
    pub delta: i16,
}

impl LzfseDecoderEntry {
    /// Creates a new decoder entry.
    pub fn new() -> Self {
        Self {
            number_of_bits: 0,
            symbol: 0,
            delta: 0,
        }
    }
}

/// Value decoder entry for decompressing LZFSE compressed data.
struct LzfseValueDecoderEntry {
    /// The (total) number of bits.
    pub number_of_bits: u8,

    /// The value bits.
    pub value_bits: u8,

    /// The delta.
    pub delta: i16,

    /// The value base.
    pub value_base: i32,

    /// The value bitmask.
    pub value_bitmask: u32,
}

impl LzfseValueDecoderEntry {
    /// Creates a new value decoder entry.
    pub fn new() -> Self {
        Self {
            number_of_bits: 0,
            value_bits: 0,
            delta: 0,
            value_base: 0,
            value_bitmask: 0,
        }
    }
}

/// Decoder for decompressing LZFSE compressed data.
struct LzfseDecoder {
    /// The number of literals.
    pub number_of_literals: u32,

    /// The number of L, M and D values.
    pub number_of_lmd_values: u32,

    /// The literals data size.
    pub literals_data_size: u32,

    /// The L, M and D values data size.
    pub lmd_values_data_size: u32,

    /// The literal states.
    pub literal_states: [u16; 4],

    /// The L value states.
    pub l_value_state: u16,

    /// The M value states.
    pub m_value_state: u16,

    /// The D value states.
    pub d_value_state: u16,

    /// The literal number of bits.
    pub literal_bits: i32,

    /// The L, M and D values number of bits.
    pub lmd_values_bits: i32,

    /// The literal decoder table.
    pub literal_decoder_table: Vec<LzfseDecoderEntry>,

    /// The L value decoder table.
    pub l_value_decoder_table: Vec<LzfseValueDecoderEntry>,

    /// The M value decoder table.
    pub m_value_decoder_table: Vec<LzfseValueDecoderEntry>,

    /// The D value decoder table.
    pub d_value_decoder_table: Vec<LzfseValueDecoderEntry>,
}

impl LzfseDecoder {
    /// Creates a new decoder.
    pub fn new() -> Self {
        Self {
            number_of_literals: 0,
            number_of_lmd_values: 0,
            literals_data_size: 0,
            lmd_values_data_size: 0,
            literal_states: [0; 4],
            l_value_state: 0,
            m_value_state: 0,
            d_value_state: 0,
            literal_bits: 0,
            lmd_values_bits: 0,
            literal_decoder_table: Vec::new(),
            l_value_decoder_table: Vec::new(),
            m_value_decoder_table: Vec::new(),
            d_value_decoder_table: Vec::new(),
        }
    }
}

/// Context for decompressing LZFSE compressed data.
pub struct LzfseContext {
    /// Mediator.
    mediator: MediatorReference,

    /// Context for decompressing LZVN compressed data.
    lzvn_context: LzvnContext,

    /// Uncompressed data size.
    pub uncompressed_data_size: usize,
}

impl LzfseContext {
    /// Creates a new context.
    pub fn new() -> Self {
        Self {
            mediator: Mediator::current(),
            lzvn_context: LzvnContext::new(),
            uncompressed_data_size: 0,
        }
    }

    /// Builds a decoder table.
    fn build_decoder_table(
        &self,
        number_of_states: i16,
        number_of_symbols: i16,
        frequency_table: &[u16],
        decoder_table: &mut Vec<LzfseDecoderEntry>,
    ) -> io::Result<()> {
        if number_of_symbols > 256 {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!(
                    "Invalid number of symbols: {} value out of bounds",
                    number_of_symbols,
                ),
            ));
        }
        let number_of_leading_zeros: u32 = number_of_states.leading_zeros();
        let mut sum_of_frequencies: i16 = 0;

        for symbol in 0..number_of_symbols {
            // Frequency contains the number of occurrences of the symbol.
            let frequency: u16 = frequency_table[symbol as usize];

            if frequency == 0 {
                continue;
            }
            sum_of_frequencies += frequency as i16;

            if sum_of_frequencies > number_of_states {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidData,
                    format!(
                        "Invalid sum of frequencies: {} value out of bounds",
                        sum_of_frequencies,
                    ),
                ));
            }
            let number_of_bits: u32 = frequency.leading_zeros() - number_of_leading_zeros;
            let base_decoder_weight: i16 =
                ((2 * number_of_states) >> number_of_bits) - frequency as i16;

            for decoder_weight in 0..frequency {
                let mut decoder_entry: LzfseDecoderEntry = LzfseDecoderEntry::new();

                decoder_entry.number_of_bits = number_of_bits as i8;
                decoder_entry.symbol = symbol as u8;
                decoder_entry.delta = if (decoder_weight as i16) < base_decoder_weight {
                    ((frequency as i16 + decoder_weight as i16) << number_of_bits)
                        - number_of_states
                } else {
                    decoder_entry.number_of_bits -= 1;

                    (decoder_weight as i16 - base_decoder_weight) << (number_of_bits - 1)
                };
                decoder_table.push(decoder_entry);
            }
        }
        Ok(())
    }

    /// Builds a value decoder table.
    fn build_value_decoder_table(
        &self,
        number_of_states: i16,
        number_of_symbols: i16,
        frequency_table: &[u16],
        value_bits_table: &[u8],
        value_base_table: &[i32],
        value_decoder_table: &mut Vec<LzfseValueDecoderEntry>,
    ) -> io::Result<()> {
        if number_of_symbols > 256 {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!(
                    "Invalid number of symbols: {} value out of bounds",
                    number_of_symbols,
                ),
            ));
        }
        let number_of_leading_zeros: u32 = number_of_states.leading_zeros();
        let mut sum_of_frequencies: i16 = 0;

        for symbol in 0..number_of_symbols {
            // Frequency contains the number of occurrences of the symbol.
            let frequency: u16 = frequency_table[symbol as usize];

            if frequency == 0 {
                continue;
            }
            sum_of_frequencies += frequency as i16;

            if sum_of_frequencies > number_of_states {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidData,
                    format!(
                        "Invalid sum of frequencies: {} value out of bounds",
                        sum_of_frequencies,
                    ),
                ));
            }
            let number_of_bits: u32 = frequency.leading_zeros() - number_of_leading_zeros;
            let base_decoder_weight: i16 =
                ((2 * number_of_states) >> number_of_bits) - frequency as i16;

            let value_bits: u8 = value_bits_table[symbol as usize];
            let value_base: i32 = value_base_table[symbol as usize];

            for decoder_weight in 0..frequency {
                let mut value_decoder_entry: LzfseValueDecoderEntry = LzfseValueDecoderEntry::new();

                value_decoder_entry.value_bits = value_bits;
                value_decoder_entry.value_base = value_base;
                value_decoder_entry.value_bitmask = (1 << value_bits) - 1;
                value_decoder_entry.number_of_bits = number_of_bits as u8 + value_bits;
                value_decoder_entry.delta = if (decoder_weight as i16) < base_decoder_weight {
                    ((frequency as i16 + decoder_weight as i16) << number_of_bits)
                        - number_of_states
                } else {
                    value_decoder_entry.number_of_bits -= 1;

                    (decoder_weight as i16 - base_decoder_weight) << (number_of_bits - 1)
                };
                value_decoder_table.push(value_decoder_entry);
            }
        }
        Ok(())
    }

    /// Decompress data.
    pub fn decompress(
        &mut self,
        compressed_data: &[u8],
        uncompressed_data: &mut [u8],
    ) -> io::Result<()> {
        let mut compressed_data_offset: usize = 0;
        let compressed_data_size: usize = uncompressed_data.len();
        let mut frequency_table: [u16; 360] = [0; 360];
        let mut uncompressed_data_offset: usize = 0;
        let uncompressed_data_size: usize = uncompressed_data.len();

        while compressed_data_offset < compressed_data_size {
            if uncompressed_data_offset >= uncompressed_data_size {
                break;
            }
            if 4 > compressed_data_size - compressed_data_offset {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidData,
                    "Invalid compressed data value too small",
                ));
            }
            let block_marker: u32 = bytes_to_u32_le!(compressed_data, compressed_data_offset);

            match block_marker {
                LZFSE_END_OF_STREAM_BLOCK_MARKER => {
                    if self.mediator.debug_output {
                        self.mediator.debug_print(format!(
                            "    block_marker: {}{}{}{} (end-of-stream)\n",
                            compressed_data[compressed_data_offset] as char,
                            compressed_data[compressed_data_offset + 1] as char,
                            compressed_data[compressed_data_offset + 2] as char,
                            compressed_data[compressed_data_offset + 3] as char,
                        ));
                    }
                    break;
                }
                LZFSE_UNCOMPRESSED_BLOCK_MARKER => {
                    if self.mediator.debug_output {
                        self.mediator.debug_print(format!(
                            "    block_marker: {}{}{}{} (uncompressed)\n",
                            compressed_data[compressed_data_offset] as char,
                            compressed_data[compressed_data_offset + 1] as char,
                            compressed_data[compressed_data_offset + 2] as char,
                            compressed_data[compressed_data_offset + 3] as char,
                        ));
                    }
                }
                LZFSE_COMPRESSED_BLOCK_V1_MARKER => {
                    if self.mediator.debug_output {
                        self.mediator.debug_print(format!(
                            "    block_marker: {}{}{}{} (compressed version 1)\n",
                            compressed_data[compressed_data_offset] as char,
                            compressed_data[compressed_data_offset + 1] as char,
                            compressed_data[compressed_data_offset + 2] as char,
                            compressed_data[compressed_data_offset + 3] as char,
                        ));
                    }
                }
                LZFSE_COMPRESSED_BLOCK_V2_MARKER => {
                    if self.mediator.debug_output {
                        self.mediator.debug_print(format!(
                            "    block_marker: {}{}{}{} (compressed version 2)\n",
                            compressed_data[compressed_data_offset] as char,
                            compressed_data[compressed_data_offset + 1] as char,
                            compressed_data[compressed_data_offset + 2] as char,
                            compressed_data[compressed_data_offset + 3] as char,
                        ));
                    }
                }
                LZFSE_COMPRESSED_BLOCK_LZVN_MARKER => {
                    if self.mediator.debug_output {
                        self.mediator.debug_print(format!(
                            "    block_marker: {}{}{}{} (compressed LZVN)\n",
                            compressed_data[compressed_data_offset] as char,
                            compressed_data[compressed_data_offset + 1] as char,
                            compressed_data[compressed_data_offset + 2] as char,
                            compressed_data[compressed_data_offset + 3] as char,
                        ));
                    }
                }
                _ => {
                    if self.mediator.debug_output {
                        self.mediator
                            .debug_print(format!("    block_marker: 0x{:08x}\n", block_marker));
                    }
                    return Err(io::Error::new(
                        io::ErrorKind::InvalidData,
                        format!("Unsupported block marker: 0x{:08x}", block_marker),
                    ));
                }
            };
            compressed_data_offset += 4;

            if 4 > compressed_data_size - compressed_data_offset {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidData,
                    "Invalid compressed data value too small",
                ));
            }
            let uncompressed_block_size: u32 =
                bytes_to_u32_le!(compressed_data, compressed_data_offset);
            compressed_data_offset += 4;

            if self.mediator.debug_output {
                self.mediator.debug_print(format!(
                    "    uncompressed_block_size: {}\n",
                    uncompressed_block_size
                ));
            }
            if uncompressed_block_size as usize > uncompressed_data_size - uncompressed_data_offset
            {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidData,
                    "Invalid uncompressed data value too small",
                ));
            }
            match block_marker {
                LZFSE_UNCOMPRESSED_BLOCK_MARKER => {
                    if uncompressed_block_size as usize
                        > compressed_data_size - compressed_data_offset
                    {
                        return Err(io::Error::new(
                            io::ErrorKind::InvalidData,
                            "Invalid compressed data value too small",
                        ));
                    }
                    let compressed_data_end_offset: usize =
                        compressed_data_offset + uncompressed_block_size as usize;
                    let uncompressed_data_end_offset: usize =
                        uncompressed_data_offset + uncompressed_block_size as usize;

                    if self.mediator.debug_output {
                        self.mediator
                            .debug_print(format!("    uncompressed block data:\n"));
                        self.mediator.debug_print_data(
                            &compressed_data[compressed_data_offset..compressed_data_end_offset],
                            true,
                        );
                    }
                    uncompressed_data[uncompressed_data_offset..uncompressed_data_end_offset]
                        .copy_from_slice(
                            &compressed_data[compressed_data_offset..compressed_data_end_offset],
                        );

                    compressed_data_offset = compressed_data_end_offset;
                    uncompressed_data_offset = uncompressed_data_end_offset;
                }
                LZFSE_COMPRESSED_BLOCK_V1_MARKER | LZFSE_COMPRESSED_BLOCK_V2_MARKER => {
                    let mut decoder: LzfseDecoder = LzfseDecoder::new();

                    if block_marker == LZFSE_COMPRESSED_BLOCK_V1_MARKER {
                        self.read_block_v1_header(
                            compressed_data,
                            &mut compressed_data_offset,
                            compressed_data_size,
                            &mut decoder,
                            &mut frequency_table,
                        )?;
                    } else {
                        self.read_block_v2_header(
                            compressed_data,
                            &mut compressed_data_offset,
                            compressed_data_size,
                            &mut decoder,
                            &mut frequency_table,
                        )?;
                    }
                    self.build_value_decoder_table(
                        LZFSE_NUMBER_OF_L_VALUE_STATES,
                        LZFSE_NUMBER_OF_L_VALUE_SYMBOLS,
                        &frequency_table[0..20],
                        &LZFSE_L_VALUE_BITS_TABLE,
                        &LZFSE_L_VALUE_BASE_TABLE,
                        &mut decoder.l_value_decoder_table,
                    )?;
                    self.build_value_decoder_table(
                        LZFSE_NUMBER_OF_M_VALUE_STATES,
                        LZFSE_NUMBER_OF_M_VALUE_SYMBOLS,
                        &frequency_table[20..40],
                        &LZFSE_M_VALUE_BITS_TABLE,
                        &LZFSE_M_VALUE_BASE_TABLE,
                        &mut decoder.m_value_decoder_table,
                    )?;
                    self.build_value_decoder_table(
                        LZFSE_NUMBER_OF_D_VALUE_STATES,
                        LZFSE_NUMBER_OF_D_VALUE_SYMBOLS,
                        &frequency_table[40..104],
                        &LZFSE_D_VALUE_BITS_TABLE,
                        &LZFSE_D_VALUE_BASE_TABLE,
                        &mut decoder.d_value_decoder_table,
                    )?;
                    self.build_decoder_table(
                        LZFSE_NUMBER_OF_LITERAL_STATES,
                        LZFSE_NUMBER_OF_LITERAL_SYMBOLS,
                        &frequency_table[104..360],
                        &mut decoder.literal_decoder_table,
                    )?;
                    self.decompress_block(
                        &decoder,
                        compressed_data,
                        &mut compressed_data_offset,
                        compressed_data_size,
                        uncompressed_data,
                        &mut uncompressed_data_offset,
                        uncompressed_data_size,
                    )?;
                }
                LZFSE_COMPRESSED_BLOCK_LZVN_MARKER => {
                    if 4 > compressed_data_size - compressed_data_offset {
                        return Err(io::Error::new(
                            io::ErrorKind::InvalidData,
                            "Invalid compressed data value too small",
                        ));
                    }
                    let compressed_block_size: u32 =
                        bytes_to_u32_le!(compressed_data, compressed_data_offset);
                    compressed_data_offset += 4;

                    if compressed_block_size as usize
                        > compressed_data_size - compressed_data_offset
                    {
                        return Err(io::Error::new(
                            io::ErrorKind::InvalidData,
                            "Invalid compressed data value too small",
                        ));
                    }
                    let compressed_data_end_offset: usize =
                        compressed_data_offset + compressed_block_size as usize;
                    let uncompressed_data_end_offset: usize =
                        uncompressed_data_offset + uncompressed_block_size as usize;

                    self.lzvn_context.decompress(
                        &compressed_data[compressed_data_offset..compressed_data_end_offset],
                        &mut uncompressed_data
                            [uncompressed_data_offset..uncompressed_data_end_offset],
                    )?;

                    compressed_data_offset = compressed_data_end_offset;
                    uncompressed_data_offset = uncompressed_data_end_offset;
                }
                _ => {}
            };
        }
        self.uncompressed_data_size = uncompressed_data_offset;

        Ok(())
    }

    /// Decompress a LZFSE compressed block.
    fn decompress_block(
        &self,
        decoder: &LzfseDecoder,
        compressed_data: &[u8],
        compressed_data_offset: &mut usize,
        compressed_data_size: usize,
        uncompressed_data: &mut [u8],
        uncompressed_data_offset: &mut usize,
        uncompressed_data_size: usize,
    ) -> io::Result<()> {
        let mut data_offset: usize = *compressed_data_offset;

        if decoder.literals_data_size as usize > compressed_data_size - data_offset {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                "Invalid compressed data value too small",
            ));
        }
        let data_end_offset: usize = data_offset + decoder.literals_data_size as usize;
        let mut bitstream: LzfseBitstream = LzfseBitstream::new(compressed_data, data_end_offset);

        let mut literal_values: [u8; LZFSE_MAXIMUM_NUMBER_OF_LITERALS] =
            [0; LZFSE_MAXIMUM_NUMBER_OF_LITERALS];
        self.read_literal_values(decoder, &mut bitstream, &mut literal_values)?;

        data_offset = data_end_offset;

        if decoder.lmd_values_data_size as usize > compressed_data_size - data_offset {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                "Invalid compressed data value too small",
            ));
        }
        let data_end_offset: usize = data_offset + decoder.lmd_values_data_size as usize;
        let mut bitstream: LzfseBitstream = LzfseBitstream::new(compressed_data, data_end_offset);

        self.read_lmd_values(
            decoder,
            &mut bitstream,
            &literal_values,
            uncompressed_data,
            uncompressed_data_offset,
            uncompressed_data_size,
        )?;
        *compressed_data_offset = data_end_offset;

        Ok(())
    }

    /// Read a LZFSE block version 1 header.
    fn read_block_v1_header(
        &self,
        compressed_data: &[u8],
        compressed_data_offset: &mut usize,
        compressed_data_size: usize,
        decoder: &mut LzfseDecoder,
        frequency_table: &mut [u16],
    ) -> io::Result<()> {
        let mut data_offset: usize = *compressed_data_offset;

        if 762 > compressed_data_size - data_offset {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                "Invalid compressed data value too small",
            ));
        }
        let mut block_header: LzfseBlockV1Header = LzfseBlockV1Header::new();
        let data_end_offset: usize = data_offset + 42;

        if self.mediator.debug_output {
            self.mediator.debug_print(format!(
                "LzfseBlockV1Header data of size: 42 at offset: {} (0x{:08x})\n",
                data_offset, data_offset
            ));
            self.mediator
                .debug_print_data(&compressed_data[data_offset..data_end_offset], true);
            self.mediator
                .debug_print(LzfseBlockV1Header::debug_read_data(
                    &compressed_data[data_offset..data_end_offset],
                ));
        }
        block_header.read_data(&compressed_data[data_offset..data_end_offset], decoder)?;
        data_offset = data_end_offset;

        let data_end_offset: usize = data_offset + 720;

        if self.mediator.debug_output {
            self.mediator.debug_print(format!(
                "LzfseFrequencyTable data of size: 720 at offset: {} (0x{:08x})\n",
                data_offset, data_offset
            ));
            self.mediator
                .debug_print_data(&compressed_data[data_offset..data_end_offset], true);
            self.mediator
                .debug_print(format!("LzfseFrequencyTable {{\n"));
            self.mediator.debug_print(format!("    values: [\n"));
        }
        let mut data_offset: usize = 42;
        for frequency_table_index in 0..360 {
            let frequency_value: u16 = bytes_to_u16_le!(compressed_data, data_offset);
            data_offset += 2;

            if self.mediator.debug_output {
                if frequency_table_index % 16 == 0 {
                    self.mediator
                        .debug_print(format!("    {}", frequency_value));
                } else if frequency_table_index % 16 == 15 {
                    self.mediator
                        .debug_print(format!(", {},\n", frequency_value));
                } else {
                    self.mediator.debug_print(format!(", {}", frequency_value));
                }
            }
            frequency_table[frequency_table_index] = frequency_value;
        }
        if self.mediator.debug_output {
            self.mediator.debug_print(format!("    ],\n"));
            self.mediator.debug_print(format!("}}\n"));
        }
        *compressed_data_offset = data_offset;

        Ok(())
    }

    /// Read a LZFSE block version 2 header.
    fn read_block_v2_header(
        &self,
        compressed_data: &[u8],
        compressed_data_offset: &mut usize,
        compressed_data_size: usize,
        decoder: &mut LzfseDecoder,
        frequency_table: &mut [u16],
    ) -> io::Result<()> {
        let mut data_offset: usize = *compressed_data_offset;

        let mut block_header: LzfseBlockV2Header = LzfseBlockV2Header::new();
        let mut data_end_offset: usize = data_offset + 24;

        if self.mediator.debug_output {
            self.mediator.debug_print(format!(
                "LzfseBlockV2Header data of size: 24 at offset: {} (0x{:08x})\n",
                data_offset, data_offset
            ));
            self.mediator
                .debug_print_data(&compressed_data[data_offset..data_end_offset], true);
            self.mediator
                .debug_print(LzfseBlockV2Header::debug_read_data(
                    &compressed_data[data_offset..data_end_offset],
                ));
        }
        block_header.read_data(&compressed_data[data_offset..data_end_offset], decoder)?;
        if block_header.header_size as usize > compressed_data_size - data_offset {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                "Invalid compressed data value too small",
            ));
        }
        data_offset = data_end_offset;

        if block_header.header_size > 32 {
            let compressed_data_size: usize = block_header.header_size as usize - 32;
            data_end_offset += compressed_data_size;

            if self.mediator.debug_output {
                self.mediator.debug_print(format!(
                    "LzfseCompressedFrequencyTable data of size: {} at offset: {} (0x{:08x})\n",
                    compressed_data_size, data_offset, data_offset
                ));
                self.mediator
                    .debug_print_data(&compressed_data[data_offset..data_end_offset], true);
                self.mediator
                    .debug_print(format!("LzfseFrequencyTable {{\n"));
                self.mediator.debug_print(format!("    values: [\n"));
            }
            // TODO: use bitstream to read compressed data
            let mut number_of_bits: usize = 0;
            let mut value_32bit: u32 = 0;
            for frequency_table_index in 0..360 {
                while number_of_bits <= 24 && data_offset < data_end_offset {
                    value_32bit |= (compressed_data[data_offset] as u32) << number_of_bits;
                    data_offset += 1;
                    number_of_bits += 8;
                }
                let table_index: u32 = value_32bit & 0x0000001f;
                let frequency_value_size: u8 =
                    LZFSE_FREQUENCY_NUMBER_OF_BITS_TABLE[table_index as usize];

                let frequency_value: u16 = match frequency_value_size {
                    8 => (((value_32bit >> 4) & 0x0000000f) + 8) as u16,
                    14 => (((value_32bit >> 4) & 0x000003ff) + 24) as u16,
                    _ => LZFSE_FREQUENCY_VALUE_TABLE[table_index as usize],
                };
                if self.mediator.debug_output {
                    if frequency_table_index % 16 == 0 {
                        self.mediator
                            .debug_print(format!("        {}", frequency_value));
                    } else if frequency_table_index % 16 == 15 {
                        self.mediator
                            .debug_print(format!(", {},\n", frequency_value));
                    } else {
                        self.mediator.debug_print(format!(", {}", frequency_value));
                    }
                }
                frequency_table[frequency_table_index] = frequency_value;

                value_32bit >>= frequency_value_size;
                number_of_bits -= frequency_value_size as usize;
            }
            if self.mediator.debug_output {
                self.mediator.debug_print(format!("\n    ],\n"));
                self.mediator.debug_print(format!("}}\n"));
            }
        }
        *compressed_data_offset = data_offset;

        Ok(())
    }

    /// Read literal values.
    fn read_literal_values(
        &self,
        decoder: &LzfseDecoder,
        bitstream: &mut LzfseBitstream,
        literal_values: &mut [u8],
    ) -> io::Result<()> {
        if decoder.number_of_literals as usize > LZFSE_MAXIMUM_NUMBER_OF_LITERALS {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!(
                    "Invalid number of literals: {} value out of bounds",
                    decoder.number_of_literals,
                ),
            ));
        }
        if decoder.literal_bits < -32 || decoder.literal_bits > 0 {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!(
                    "Invalid literal bits: {} value out of bounds",
                    decoder.literal_bits,
                ),
            ));
        }
        let mut literal_states: [u16; 4] = [0; 4];
        literal_states.copy_from_slice(&decoder.literal_states);

        let number_of_bits: i32 = -1 * decoder.literal_bits;
        let _ = bitstream.get_value(number_of_bits as usize);

        for literal_index in (0..decoder.number_of_literals).step_by(4) {
            for literal_states_index in 0..4 {
                let literal_state: u16 = literal_states[literal_states_index];

                // TODO: refactor to decoder.get_literal?
                if literal_state > LZFSE_NUMBER_OF_LITERAL_STATES as u16 {
                    return Err(io::Error::new(
                        io::ErrorKind::InvalidData,
                        format!(
                            "Invalid literal state: {} value out of bounds",
                            literal_state,
                        ),
                    ));
                }
                let decoder_entry: &LzfseDecoderEntry = match decoder
                    .literal_decoder_table
                    .get(literal_state as usize)
                {
                    Some(value) => value,
                    None => {
                        return Err(io::Error::new(
                            io::ErrorKind::InvalidData,
                            format!("Missing decoder entry for literal state: {}", literal_state,),
                        ))
                    }
                };
                let value: u32 = bitstream.get_value(decoder_entry.number_of_bits as usize);
                let literal_state: i32 = (decoder_entry.delta as i32) + (value as i32);
                let literal_values_index: usize = literal_index as usize + literal_states_index;

                if self.mediator.debug_output {
                    self.mediator
                        .debug_print(format!("    value: 0x{:02x}\n", value));
                    self.mediator.debug_print(format!(
                        "    literal_values[{}]: 0x{:02x}\n",
                        literal_values_index, decoder_entry.symbol
                    ));
                    self.mediator.debug_print(format!(
                        "    literal_states[{}]: {}\n",
                        literal_states_index, literal_state
                    ));
                }
                literal_values[literal_values_index] = decoder_entry.symbol;
                literal_states[literal_states_index] = literal_state as u16;
            }
        }
        if self.mediator.debug_output {
            self.mediator.debug_print(format!("\n"));
        }
        Ok(())
    }

    /// Read L, M and D values.
    fn read_lmd_values(
        &self,
        decoder: &LzfseDecoder,
        bitstream: &mut LzfseBitstream,
        literal_values: &[u8],
        uncompressed_data: &mut [u8],
        uncompressed_data_offset: &mut usize,
        uncompressed_data_size: usize,
    ) -> io::Result<()> {
        if decoder.lmd_values_bits < -32 || decoder.lmd_values_bits > 0 {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!(
                    "Invalid L, M and D values bits: {} value out of bounds",
                    decoder.lmd_values_bits,
                ),
            ));
        }
        let mut data_offset: usize = *uncompressed_data_offset;
        let mut remaining_data_size: usize = uncompressed_data_size - data_offset;

        let mut active_d_value: i32 = 0;
        let mut literal_value_index: i32 = 0;

        let mut l_value_state: i32 = decoder.l_value_state as i32;
        let mut m_value_state: i32 = decoder.m_value_state as i32;
        let mut d_value_state: i32 = decoder.d_value_state as i32;

        let number_of_bits: i32 = -1 * decoder.lmd_values_bits;
        let _ = bitstream.get_value(number_of_bits as usize);

        for _ in 0..decoder.number_of_lmd_values {
            // TODO: refactor to decoder.get_l_value?
            if l_value_state > LZFSE_NUMBER_OF_L_VALUE_STATES as i32 {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidData,
                    format!(
                        "Invalid L value state: {} value out of bounds",
                        l_value_state,
                    ),
                ));
            }
            let value_decoder_entry: &LzfseValueDecoderEntry =
                match decoder.l_value_decoder_table.get(l_value_state as usize) {
                    Some(value) => value,
                    None => {
                        return Err(io::Error::new(
                            io::ErrorKind::InvalidData,
                            format!(
                                "Missing value decoder entry for L value state: {}",
                                l_value_state,
                            ),
                        ))
                    }
                };
            let value: u32 = bitstream.get_value(value_decoder_entry.number_of_bits as usize);
            let l_value: i32 =
                value_decoder_entry.value_base + (value & value_decoder_entry.value_bitmask) as i32;
            l_value_state = (value_decoder_entry.delta as i32)
                + (value >> (value_decoder_entry.value_bits as u32)) as i32;

            if self.mediator.debug_output {
                self.mediator
                    .debug_print(format!("    l_value: {}\n", l_value));
                self.mediator
                    .debug_print(format!("    l_value_state: {}\n", l_value_state));
            }
            // TODO: refactor to decoder.get_m_value?
            if m_value_state > LZFSE_NUMBER_OF_M_VALUE_STATES as i32 {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidData,
                    format!(
                        "Invalid M value state: {} value out of bounds",
                        m_value_state,
                    ),
                ));
            }
            let value_decoder_entry: &LzfseValueDecoderEntry =
                match decoder.m_value_decoder_table.get(m_value_state as usize) {
                    Some(value) => value,
                    None => {
                        return Err(io::Error::new(
                            io::ErrorKind::InvalidData,
                            format!(
                                "Missing value decoder entry for M value state: {}",
                                m_value_state,
                            ),
                        ))
                    }
                };
            let value: u32 = bitstream.get_value(value_decoder_entry.number_of_bits as usize);
            let m_value: i32 =
                value_decoder_entry.value_base + (value & value_decoder_entry.value_bitmask) as i32;
            m_value_state = (value_decoder_entry.delta as i32)
                + (value >> (value_decoder_entry.value_bits as u32)) as i32;

            if self.mediator.debug_output {
                self.mediator
                    .debug_print(format!("    m_value: {}\n", m_value));
                self.mediator
                    .debug_print(format!("    m_value_state: {}\n", m_value_state));
            }
            // TODO: refactor to decoder.get_d_value?
            if d_value_state > LZFSE_NUMBER_OF_D_VALUE_STATES as i32 {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidData,
                    format!(
                        "Invalid D value state: {} value out of bounds",
                        d_value_state,
                    ),
                ));
            }
            let value_decoder_entry: &LzfseValueDecoderEntry =
                match decoder.d_value_decoder_table.get(d_value_state as usize) {
                    Some(value) => value,
                    None => {
                        return Err(io::Error::new(
                            io::ErrorKind::InvalidData,
                            format!(
                                "Missing value decoder entry for D value state: {}",
                                d_value_state,
                            ),
                        ))
                    }
                };
            let value: u32 = bitstream.get_value(value_decoder_entry.number_of_bits as usize);
            let d_value: i32 =
                value_decoder_entry.value_base + (value & value_decoder_entry.value_bitmask) as i32;
            d_value_state = (value_decoder_entry.delta as i32)
                + (value >> (value_decoder_entry.value_bits as u32)) as i32;

            if self.mediator.debug_output {
                self.mediator
                    .debug_print(format!("    d_value: {}\n", d_value));
                self.mediator
                    .debug_print(format!("    d_value_state: {}\n", d_value_state));
            }
            if d_value != 0 {
                active_d_value = d_value;
            }
            let maximum_l_value: usize =
                cmp::min(LZFSE_MAXIMUM_NUMBER_OF_LITERALS - 1, remaining_data_size);
            if l_value < 0
                || l_value as usize > maximum_l_value
                || literal_value_index > (LZFSE_MAXIMUM_NUMBER_OF_LITERALS as i32) - l_value
            {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidData,
                    format!("Invalid L value: {} value out of bounds", l_value,),
                ));
            }
            for _ in 0..l_value {
                uncompressed_data[data_offset] = literal_values[literal_value_index as usize];

                data_offset += 1;
                literal_value_index += 1;
            }
            remaining_data_size -= l_value as usize;

            if m_value < 0 || m_value > remaining_data_size as i32 {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidData,
                    format!("Invalid M value: {} value out of bounds", m_value,),
                ));
            }
            if active_d_value < 0 || active_d_value as usize > data_offset {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidData,
                    format!("Invalid D value: {} value out of bounds", active_d_value,),
                ));
            }
            let mut compression_offset: usize = data_offset - active_d_value as usize;

            for _ in 0..m_value {
                uncompressed_data[data_offset] = uncompressed_data[compression_offset];

                data_offset += 1;
                compression_offset += 1;
            }
            remaining_data_size -= m_value as usize;
        }
        if self.mediator.debug_output {
            self.mediator.debug_print(format!("\n"));
        }
        *uncompressed_data_offset = data_offset;

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_test_data() -> Vec<u8> {
        return vec![
            0x62, 0x76, 0x78, 0x32, 0x00, 0x10, 0x00, 0x00, 0x44, 0x00, 0x30, 0x02, 0x00, 0x05,
            0x00, 0x40, 0xe4, 0x8b, 0xd9, 0xa2, 0xc9, 0x0f, 0x00, 0x50, 0xa5, 0x00, 0x00, 0x00,
            0x39, 0x58, 0x30, 0x0d, 0x47, 0x70, 0x05, 0x70, 0x05, 0x00, 0x70, 0x75, 0xc5, 0x15,
            0x00, 0x57, 0x00, 0x70, 0x05, 0xc0, 0x07, 0xf0, 0xb5, 0xfc, 0x06, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x72,
            0x01, 0xdc, 0x01, 0x00, 0xc0, 0xdd, 0x1b, 0x00, 0x00, 0xdc, 0x01, 0x70, 0x77, 0x07,
            0x00, 0xdc, 0x01, 0x00, 0x77, 0x70, 0x77, 0x07, 0x00, 0x00, 0x00, 0x77, 0x00, 0xdc,
            0xdd, 0x01, 0x00, 0x00, 0xdc, 0x01, 0x00, 0x70, 0x07, 0x77, 0x5f, 0x01, 0x77, 0xbc,
            0x01, 0x77, 0x77, 0xdc, 0x01, 0x70, 0x07, 0x00, 0x70, 0x07, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x1b, 0xc0, 0x1d, 0x00, 0x00, 0x77, 0x00,
            0xdc, 0x01, 0x00, 0x77, 0x00, 0x00, 0x00, 0x00, 0xdc, 0xdd, 0xdd, 0x01, 0xdc, 0x01,
            0x00, 0x70, 0x07, 0x70, 0x07, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0x1c,
            0x68, 0xbd, 0xc5, 0xd0, 0xc4, 0x3c, 0x8c, 0xb7, 0xbe, 0x86, 0x9b, 0xeb, 0x76, 0x65,
            0xd2, 0x38, 0x3e, 0x26, 0x5c, 0x31, 0x96, 0xe7, 0x57, 0xc5, 0x31, 0xd3, 0x83, 0xb0,
            0x45, 0x9f, 0xa7, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0xd3,
            0xfc, 0x7f, 0x9c, 0x51, 0x03, 0x62, 0x76, 0x78, 0x24,
        ];
    }

    #[test]
    fn test_bitstream_get_value() {
        let test_data: Vec<u8> = get_test_data();

        let mut test_bitstream: LzfseBitstream = LzfseBitstream::new(&test_data, 198);

        let test_value: u32 = test_bitstream.get_value(0);
        assert_eq!(test_value, 0);

        let test_value: u32 = test_bitstream.get_value(4);
        assert_eq!(test_value, 0x00000009);

        let test_value: u32 = test_bitstream.get_value(12);
        assert_eq!(test_value, 0x00000f45);

        let test_value: u32 = test_bitstream.get_value(24);
        assert_eq!(test_value, 0x00b083d3);
    }

    #[test]
    fn test_bitstream_skip_bits() {
        let test_data: Vec<u8> = get_test_data();

        let mut test_bitstream: LzfseBitstream = LzfseBitstream::new(&test_data, 198);

        test_bitstream.skip_bits(4);
        let test_value: u32 = test_bitstream.get_value(12);
        assert_eq!(test_value, 0x00000f45);
    }

    #[test]
    fn test_decompress() -> io::Result<()> {
        let test_data: Vec<u8> = get_test_data();
        let mut test_context: LzfseContext = LzfseContext::new();

        let expected_data: [u8; 4096] = [
            0xef, 0x57, 0x34, 0x7c, 0x00, 0x00, 0xaa, 0x11, 0xaa, 0x11, 0x00, 0x30, 0x65, 0x43,
            0xec, 0xac, 0x65, 0xf0, 0x4a, 0xdd, 0xc4, 0xe7, 0x19, 0x49, 0xbc, 0x05, 0xd6, 0x6a,
            0xb6, 0x33, 0x10, 0xd8, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd7, 0x1f,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x64, 0x00, 0x69, 0x00, 0x73, 0x00, 0x6b, 0x00, 0x20, 0x00, 0x69, 0x00, 0x6d, 0x00,
            0x61, 0x00, 0x67, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];
        let mut uncompressed_data: Vec<u8> = vec![0; 4096];
        test_context.decompress(&test_data, &mut uncompressed_data)?;
        assert_eq!(uncompressed_data, expected_data);

        Ok(())
    }
}
