/* Copyright 2024 Joachim Metz <joachim.metz@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may
 * obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

use std::io;

use crate::datetime::DateTime;
use crate::types::SharedValue;
use crate::vfs::enums::VfsFileType;
use crate::vfs::path::VfsPath;
use crate::vfs::traits::{VfsDataStream, VfsFileEntry};
use crate::vfs::types::{VfsDataStreamReference, VfsPathReference};

/// Wrapper file entry.
pub struct WrapperVfsFileEntry {
    /// Location.
    location: String,

    /// Data stream reference.
    data_stream: VfsDataStreamReference,

    /// File type.
    file_type: VfsFileType,
}

impl WrapperVfsFileEntry {
    /// Creates a new file entry.
    pub fn new<T: VfsDataStream + 'static>(data_stream: Option<T>) -> Self {
        let shared_data_stream: VfsDataStreamReference = match data_stream {
            Some(data_stream) => SharedValue::new(Box::new(data_stream)),
            None => SharedValue::none(),
        };
        Self {
            location: String::new(),
            data_stream: shared_data_stream,
            file_type: VfsFileType::NotSet,
        }
    }

    /// Initializes the file entry.
    pub(crate) fn initialize(&mut self, path: &VfsPath) -> io::Result<()> {
        let parent_path: Option<VfsPathReference> = path.get_parent();
        if parent_path.is_none() {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "Parent missing in path",
            ));
        }
        match path.location.as_str() {
            "/" => {
                self.file_type = VfsFileType::Directory;
            }
            _ => {
                self.file_type = VfsFileType::File;
            }
        };
        self.location = path.location.clone();

        Ok(())
    }
}

impl VfsFileEntry for WrapperVfsFileEntry {
    /// Retrieves the access time.
    fn get_access_time(&self) -> Option<&DateTime> {
        None
    }

    /// Retrieves the change time.
    fn get_change_time(&self) -> Option<&DateTime> {
        None
    }

    /// Retrieves the creation time.
    fn get_creation_time(&self) -> Option<&DateTime> {
        None
    }

    /// Retrieves the modification time.
    fn get_modification_time(&self) -> Option<&DateTime> {
        None
    }

    /// Retrieves the file type.
    fn get_vfs_file_type(&self) -> VfsFileType {
        self.file_type.clone()
    }

    /// Opens a data stream with the specified name.
    fn open_data_stream(&self, name: Option<&str>) -> io::Result<Option<VfsDataStreamReference>> {
        if self.file_type != VfsFileType::File || name.is_some() || self.data_stream.is_none() {
            return Ok(None);
        }
        Ok(Some(self.data_stream.clone()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use crate::formats::apm::{ApmPartition, ApmVolumeSystem};
    use crate::vfs::context::VfsContext;
    use crate::vfs::enums::VfsPathType;
    use crate::vfs::traits::VfsFileSystem;
    use crate::vfs::types::VfsFileSystemReference;

    #[test]
    fn test_initialize() -> io::Result<()> {
        let mut vfs_file_entry: WrapperVfsFileEntry =
            WrapperVfsFileEntry::new::<ApmPartition>(None);

        let os_vfs_path: VfsPath = VfsPath::new(VfsPathType::Os, "./test_data/apm/apm.dmg", None);
        let vfs_path: VfsPath = VfsPath::new(VfsPathType::Os, "/", Some(os_vfs_path));
        vfs_file_entry.initialize(&vfs_path)?;
        assert!(vfs_file_entry.file_type == VfsFileType::Directory);

        Ok(())
    }

    #[test]
    fn test_open_data_stream() -> io::Result<()> {
        let mut vfs_context: VfsContext = VfsContext::new();

        let vfs_file_system_path: VfsPath = VfsPath::new(VfsPathType::Os, "/", None);
        let vfs_file_system: VfsFileSystemReference =
            vfs_context.open_file_system(&vfs_file_system_path)?;

        let mut volume_system = ApmVolumeSystem::new();

        let vfs_path: VfsPath = VfsPath::new(VfsPathType::Os, "./test_data/apm/apm.dmg", None);
        volume_system.open(&vfs_file_system, &vfs_path)?;

        let partition: ApmPartition = volume_system.get_partition_by_index(0)?;

        let mut vfs_file_entry: WrapperVfsFileEntry =
            WrapperVfsFileEntry::new::<ApmPartition>(Some(partition));

        let os_vfs_path: VfsPath = VfsPath::new(VfsPathType::Os, "./test_data/apm/apm.dmg", None);
        let vfs_path: VfsPath = VfsPath::new(VfsPathType::Apm, "/apm1", Some(os_vfs_path));
        vfs_file_entry.initialize(&vfs_path)?;

        let result: Option<VfsDataStreamReference> = vfs_file_entry.open_data_stream(None)?;

        let vfs_data_stream: VfsDataStreamReference = match result {
            Some(data_stream) => data_stream,
            None => {
                return Err(io::Error::new(
                    io::ErrorKind::NotFound,
                    format!("Missing data stream"),
                ))
            }
        };
        let mut test_data: Vec<u8> = vec![0; 512];
        let read_count: usize = match vfs_data_stream.with_write_lock() {
            Ok(mut data_stream) => {
                data_stream.read_at_position(&mut test_data, io::SeekFrom::Start(1024))?
            }
            Err(error) => return Err(crate::error_to_io_error!(error)),
        };
        let expected_data: [u8; 512] = [
            0x48, 0x2b, 0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x31, 0x30, 0x2e, 0x30, 0x00, 0x00,
            0x00, 0x00, 0xdd, 0x46, 0x8d, 0xdf, 0xdd, 0x46, 0x71, 0xc2, 0x00, 0x00, 0x00, 0x00,
            0xdd, 0x46, 0x71, 0xbf, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
            0x10, 0x00, 0x00, 0x00, 0x03, 0xf6, 0x00, 0x00, 0x02, 0xdf, 0x00, 0x00, 0x01, 0x65,
            0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x3e, 0x73, 0x0f, 0x40, 0xa9, 0x79, 0xed,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
            0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00,
            0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        assert_eq!(read_count, 512);
        assert_eq!(test_data, expected_data);

        Ok(())
    }
}
