/* Copyright 2024-2025 Joachim Metz <joachim.metz@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may
 * obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

use keramics_core::mediator::Mediator;
use keramics_core::{DataStream, DataStreamReference, ErrorTrace};

use super::attribute_list_entry::NtfsAttributeListEntry;
use super::block_stream::NtfsBlockStream;
use super::constants::*;
use super::mft_attribute::NtfsMftAttribute;

/// New Technologies File System (NTFS) attribute list.
pub struct NtfsAttributeList {
    /// Entries.
    pub entries: Vec<NtfsAttributeListEntry>,
}

impl NtfsAttributeList {
    /// Creates a new attribute list.
    pub fn new() -> Self {
        Self {
            entries: Vec::new(),
        }
    }

    /// Reads the attribute list from a buffer.
    fn read_data(&mut self, data: &[u8]) -> Result<(), ErrorTrace> {
        let mut data_offset: usize = 0;
        let data_size: usize = data.len();

        while data_offset < data_size {
            let mediator = Mediator::current();
            if mediator.debug_output {
                mediator.debug_print(NtfsAttributeListEntry::debug_read_data(
                    &data[data_offset..],
                ));
            }
            let mut entry: NtfsAttributeListEntry = NtfsAttributeListEntry::new();
            entry.read_data(&data[data_offset..])?;

            // TODO: read name.
            // TODO: print remaining data.

            data_offset += entry.attribute_size as usize;

            self.entries.push(entry);
        }
        Ok(())
    }

    /// Reads the attribute list from a MFT attribute.
    pub fn read_attribute(
        &mut self,
        data_attribute: &NtfsMftAttribute,
        data_stream: &DataStreamReference,
        cluster_block_size: u32,
    ) -> Result<(), ErrorTrace> {
        if data_attribute.attribute_type != NTFS_ATTRIBUTE_TYPE_ATTRIBUTE_LIST {
            return Err(keramics_core::error_trace_new!(format!(
                "Unsupported attribute type: 0x{:08x}",
                data_attribute.attribute_type
            )));
        }
        if data_attribute.is_compressed() {
            return Err(keramics_core::error_trace_new!(
                "Unsupported compressed $ATTRIBUTE_LIST attribute"
            ));
        }
        if data_attribute.is_resident() {
            self.read_data(&data_attribute.resident_data)?;
        } else {
            let mut block_stream: NtfsBlockStream = NtfsBlockStream::new(cluster_block_size);
            block_stream.open(data_stream, data_attribute)?;

            let mut cluster_block: Vec<u8> = vec![0; cluster_block_size as usize];
            loop {
                let read_count: usize = match block_stream.read(&mut cluster_block) {
                    Ok(read_count) => read_count,
                    Err(mut error) => {
                        keramics_core::error_trace_add_frame!(
                            error,
                            "Unable to read attribute list from block stream"
                        );
                        return Err(error);
                    }
                };
                if read_count == 0 {
                    break;
                }
                self.read_data(&cluster_block[..read_count])?;
            }
        };
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_test_data() -> Vec<u8> {
        return vec![
            0x20, 0x00, 0x00, 0x00, 0x70, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x0f, 0x00, 0x58, 0x01, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
            0x20, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x44, 0x43, 0x00, 0x00, 0x00, 0x00,
            0x30, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x28, 0x00, 0x04, 0x1a, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x00, 0x00, 0x24, 0x00, 0x53, 0x00, 0x44, 0x00, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x28, 0x00, 0x04, 0x1a, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x11, 0x00,
            0x24, 0x00, 0x53, 0x00, 0x44, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x90, 0x00, 0x00, 0x00, 0x28, 0x00, 0x04, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x10, 0x00, 0x24, 0x00,
            0x53, 0x00, 0x49, 0x00, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00,
            0x00, 0x00, 0x28, 0x00, 0x04, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xc8, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x24, 0x00, 0x53, 0x00,
            0x44, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00,
            0x28, 0x00, 0x04, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x08,
            0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x24, 0x00, 0x53, 0x00, 0x49, 0x00,
            0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x28, 0x00,
            0x04, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x08, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x05, 0x00, 0x24, 0x00, 0x53, 0x00, 0x44, 0x00, 0x48, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x28, 0x00, 0x04, 0x1a,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x08, 0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x06, 0x00, 0x24, 0x00, 0x53, 0x00, 0x49, 0x00, 0x49, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ];
    }

    // TODO: add tests for read_data
    // TODO: add tests for read_attribute
}
