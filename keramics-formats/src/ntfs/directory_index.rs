/* Copyright 2024-2025 Joachim Metz <joachim.metz@gmail.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may
 * obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

use std::cmp::Ordering;
use std::collections::HashMap;
use std::sync::Arc;

use keramics_core::mediator::{Mediator, MediatorReference};
use keramics_core::{DataStreamReference, ErrorTrace};
use keramics_types::{Ucs2String, bytes_to_u64_le};

use super::constants::*;
use super::directory_entries::NtfsDirectoryEntries;
use super::directory_entry::NtfsDirectoryEntry;
use super::file_name::NtfsFileName;
use super::index::NtfsIndex;
use super::index_entry::NtfsIndexEntry;
use super::index_node_header::NtfsIndexNodeHeader;
use super::index_root_header::NtfsIndexRootHeader;
use super::index_value::NtfsIndexValue;
use super::mft_attribute::NtfsMftAttribute;
use super::mft_attribute_group::NtfsMftAttributeGroup;
use super::mft_attributes::NtfsMftAttributes;
use super::standard_information::NtfsStandardInformation;

/// New Technologies File System (NTFS) directory index.
pub struct NtfsDirectoryIndex {
    /// Mediator.
    mediator: MediatorReference,

    /// Case folding mappings.
    pub case_folding_mappings: Arc<HashMap<u16, u16>>,

    /// Index.
    index: NtfsIndex,

    /// Root node data.
    root_node_data: Vec<u8>,

    /// Value to indicate that the index was initialized.
    pub is_initialized: bool,

    /// Value to indicate that the index uses case folding.
    use_case_folding: bool,
}

impl NtfsDirectoryIndex {
    /// Creates a new directory index.
    pub fn new(cluster_block_size: u32, case_folding_mappings: &Arc<HashMap<u16, u16>>) -> Self {
        Self {
            mediator: Mediator::current(),
            case_folding_mappings: case_folding_mappings.clone(),
            index: NtfsIndex::new(cluster_block_size),
            root_node_data: Vec::new(),
            is_initialized: false,
            use_case_folding: true,
        }
    }

    /// Initializes the directory index.
    pub fn initialize(&mut self, mft_attributes: &NtfsMftAttributes) -> Result<(), ErrorTrace> {
        let i30_index_name: Option<Ucs2String> = Some(Ucs2String::from("$I30"));
        let i30_attribute_group: &NtfsMftAttributeGroup =
            match mft_attributes.get_attribute_group(&i30_index_name) {
                Some(attribute_group) => attribute_group,
                None => {
                    return Err(keramics_core::error_trace_new!("Missing $I30 attributes"));
                }
            };
        let i30_index_root_attribute: &NtfsMftAttribute = match mft_attributes
            .get_attribute_for_group(i30_attribute_group, NTFS_ATTRIBUTE_TYPE_INDEX_ROOT)
        {
            Some(mft_attribute) => mft_attribute,
            None => {
                return Err(keramics_core::error_trace_new!(
                    "Missing $I30 $INDEX_ROOT attribute"
                ));
            }
        };
        if !i30_index_root_attribute.is_resident() {
            return Err(keramics_core::error_trace_new!(
                "Unsupported non-resident $I30 $INDEX_ROOT attribute"
            ));
        }
        let mut index_root_header: NtfsIndexRootHeader = NtfsIndexRootHeader::new();

        if self.mediator.debug_output {
            self.mediator
                .debug_print(NtfsIndexRootHeader::debug_read_data(
                    &i30_index_root_attribute.resident_data,
                ));
        }
        match index_root_header.read_data(&i30_index_root_attribute.resident_data) {
            Ok(_) => {}
            Err(mut error) => {
                keramics_core::error_trace_add_frame!(error, "Unable to read index root header");
                return Err(error);
            }
        }
        if index_root_header.attribute_type != NTFS_ATTRIBUTE_TYPE_FILE_NAME {
            return Err(keramics_core::error_trace_new!(format!(
                "Unsupported $I30 $INDEX_ROOT attribute type: 0x{:08x}",
                index_root_header.attribute_type
            )));
        }
        if index_root_header.collation_type != 1 {
            return Err(keramics_core::error_trace_new!(format!(
                "Unsupported $I30 $INDEX_ROOT collation type: 0x{:08x}",
                index_root_header.collation_type
            )));
        }
        // Note that 2097152 is an arbitrary chosen limit, given 2048 KiB is the largest known
        // cluster block size.
        if index_root_header.index_entry_size < 20 || index_root_header.index_entry_size > 2097152 {
            return Err(keramics_core::error_trace_new!(format!(
                "Unsupported $I30 index entry size: {} value out of bounds",
                index_root_header.index_entry_size
            )));
        }
        match mft_attributes.get_attribute(&None, NTFS_ATTRIBUTE_TYPE_STANDARD_INFORMATION) {
            Some(mft_attribute) => {
                let standard_information: NtfsStandardInformation =
                    match NtfsStandardInformation::from_attribute(mft_attribute) {
                        Ok(standard_information) => standard_information,
                        Err(mut error) => {
                            keramics_core::error_trace_add_frame!(
                                error,
                                "Unable to create standard information from attribute"
                            );
                            return Err(error);
                        }
                    };
                if standard_information.maximum_number_of_versions == 0
                    && standard_information.version_number == 1
                {
                    self.use_case_folding = false;
                }
            }
            None => {}
        }
        // Note that the $INDEX_ALLOCATION attribute is optional.
        match mft_attributes
            .get_attribute_for_group(i30_attribute_group, NTFS_ATTRIBUTE_TYPE_INDEX_ALLOCATION)
        {
            Some(mft_attribute) => match self
                .index
                .initialize(index_root_header.index_entry_size, mft_attribute)
            {
                Ok(standard_information) => standard_information,
                Err(mut error) => {
                    keramics_core::error_trace_add_frame!(error, "Unable to initialize index");
                    return Err(error);
                }
            },
            None => {}
        };

        // The $BITMAP attribute is optional.

        // TODO: keep reference of $INDEX_ROOT attribute instead of cloning the data.
        self.root_node_data = i30_index_root_attribute.resident_data.clone();
        self.is_initialized = true;

        Ok(())
    }

    /// Retrieves a directory entry by name.
    pub fn get_directory_entry_by_name(
        &self,
        data_stream: &DataStreamReference,
        name: &Ucs2String,
    ) -> Result<Option<NtfsDirectoryEntry>, ErrorTrace> {
        if !self.is_initialized {
            return Err(keramics_core::error_trace_new!(
                "Directory index was not initialized"
            ));
        }
        if self.use_case_folding {
            let case_folded_name: Ucs2String =
                Ucs2String::new_with_case_folding(name, &self.case_folding_mappings);

            self.get_directory_entry_by_name_from_node(
                &self.root_node_data,
                16,
                data_stream,
                &case_folded_name,
            )
        } else {
            self.get_directory_entry_by_name_from_node(&self.root_node_data, 16, data_stream, name)
        }
    }

    /// Retrieves a directory entry by name from an index node.
    fn get_directory_entry_by_name_from_node(
        &self,
        data: &[u8],
        index_node_offset: usize,
        data_stream: &DataStreamReference,
        name: &Ucs2String,
    ) -> Result<Option<NtfsDirectoryEntry>, ErrorTrace> {
        let (index_node_size, index_values_offset): (usize, usize) = match self
            .read_index_node_header(data, index_node_offset)
        {
            Ok(result) => result,
            Err(mut error) => {
                keramics_core::error_trace_add_frame!(error, "Unable to read index node header");
                return Err(error);
            }
        };
        if index_node_size == 0 {
            return Ok(None);
        }
        let mut index_value_offset: usize = index_node_offset + index_values_offset;
        let index_values_end_offset: usize = index_node_offset + index_node_size;

        // Fix-up values can be stored between the index node and values.

        let mut is_branch: bool = false;
        let mut value_data_size: usize = 0;

        while index_value_offset < index_values_end_offset {
            let index_value: NtfsIndexValue =
                match self.read_index_value(data, index_value_offset, index_values_end_offset) {
                    Ok(index_value) => index_value,
                    Err(mut error) => {
                        keramics_core::error_trace_add_frame!(error, "Unable to read index value");
                        return Err(error);
                    }
                };
            index_value_offset += 16;

            let key_data_size: usize = index_value.key_data_size as usize;
            let key_data_offset: usize = index_value_offset;

            if key_data_size > 0 {
                let key_data_end_offset: usize = key_data_offset + key_data_size;

                if key_data_end_offset > index_values_end_offset {
                    return Err(keramics_core::error_trace_new!(format!(
                        "Invalid index value key data size: {} value out of bounds",
                        key_data_size,
                    )));
                }
                index_value_offset = key_data_end_offset;
            }
            is_branch = index_value.flags & NTFS_INDEX_VALUE_FLAG_IS_BRANCH != 0;
            value_data_size = (index_value.size as usize) - 16 - key_data_size;

            if index_value.flags & NTFS_INDEX_VALUE_FLAG_IS_LAST != 0 {
                break;
            }
            if key_data_size == 0 {
                return Err(keramics_core::error_trace_new!("Missing key data"));
            }
            let file_name: NtfsFileName =
                match self.read_index_key(data, key_data_offset, key_data_size) {
                    Ok(file_name) => file_name,
                    Err(mut error) => {
                        keramics_core::error_trace_add_frame!(error, "Unable to read index key");
                        return Err(error);
                    }
                };
            let result: Ordering = if self.use_case_folding {
                let case_folded_name: Ucs2String =
                    Ucs2String::new_with_case_folding(&file_name.name, &self.case_folding_mappings);

                // TODO: add a compare_with_case_folding
                case_folded_name.compare(name)
            } else {
                file_name.name.compare(name)
            };
            if result == Ordering::Equal {
                let directory_entry: NtfsDirectoryEntry =
                    NtfsDirectoryEntry::new(index_value.file_reference, file_name);
                return Ok(Some(directory_entry));
            }
            if result == Ordering::Greater && is_branch {
                break;
            }
            index_value_offset += value_data_size;

            let alignment_padding: usize = index_value_offset % 8;
            if alignment_padding > 0 {
                // TODO: debug print 8-byte alignment padding.

                index_value_offset += 8 - alignment_padding;
            }
        }
        if is_branch {
            let sub_node_vcn: u64 =
                match self.read_index_branch_value(data, index_value_offset, value_data_size) {
                    Ok(index_branch_value) => index_branch_value,
                    Err(mut error) => {
                        keramics_core::error_trace_add_frame!(
                            error,
                            "Unable to read index branch value"
                        );
                        return Err(error);
                    }
                };
            // TODO: skip if sub node is not allocated.

            let index_entry: NtfsIndexEntry = match self
                .index
                .get_entry_at_cluster_block(data_stream, sub_node_vcn)
            {
                Ok(index_entry) => index_entry,
                Err(mut error) => {
                    keramics_core::error_trace_add_frame!(error, "Unable to retrieve index entry");
                    return Err(error);
                }
            };
            let result: Option<NtfsDirectoryEntry> = match self
                .get_directory_entry_by_name_from_node(&index_entry.data, 24, data_stream, name)
            {
                Ok(result) => result,
                Err(mut error) => {
                    keramics_core::error_trace_add_frame!(
                        error,
                        "Unable to retrieve directory entry from node"
                    );
                    return Err(error);
                }
            };
            match result {
                Some(directory_entry) => return Ok(Some(directory_entry)),
                None => {}
            }
        }
        Ok(None)
    }

    /// Retrieves the directory entries.
    pub fn get_directory_entries(
        &self,
        data_stream: &DataStreamReference,
        entries: &mut NtfsDirectoryEntries,
    ) -> Result<(), ErrorTrace> {
        if !self.is_initialized {
            return Err(keramics_core::error_trace_new!(
                "Directory index was not initialized"
            ));
        }
        self.get_directory_entries_from_node(&self.root_node_data, 16, data_stream, entries)
    }

    /// Retrieves the directory entries from an index node.
    fn get_directory_entries_from_node(
        &self,
        data: &[u8],
        index_node_offset: usize,
        data_stream: &DataStreamReference,
        entries: &mut NtfsDirectoryEntries,
    ) -> Result<(), ErrorTrace> {
        let (index_node_size, index_values_offset): (usize, usize) = match self
            .read_index_node_header(data, index_node_offset)
        {
            Ok(result) => result,
            Err(mut error) => {
                keramics_core::error_trace_add_frame!(error, "Unable to read index node header");
                return Err(error);
            }
        };
        if index_node_size == 0 {
            return Ok(());
        }
        let mut index_value_offset: usize = index_node_offset + index_values_offset;
        let index_values_end_offset: usize = index_node_offset + index_node_size;

        // Fix-up values can be stored between the index node and values.

        while index_value_offset < index_values_end_offset {
            let index_value: NtfsIndexValue =
                match self.read_index_value(data, index_value_offset, index_values_end_offset) {
                    Ok(index_value) => index_value,
                    Err(mut error) => {
                        keramics_core::error_trace_add_frame!(error, "Unable to read index value");
                        return Err(error);
                    }
                };
            index_value_offset += 16;

            let key_data_size: usize = index_value.key_data_size as usize;
            let key_data_offset: usize = index_value_offset;

            if key_data_size > 0 {
                let key_data_end_offset: usize = key_data_offset + key_data_size;

                if key_data_end_offset > index_values_end_offset {
                    return Err(keramics_core::error_trace_new!(format!(
                        "Invalid index value key data size: {} value out of bounds",
                        key_data_size,
                    )));
                }
                index_value_offset = key_data_end_offset;
            }
            let value_data_size: usize = (index_value.size as usize) - 16 - key_data_size;

            if index_value.flags & NTFS_INDEX_VALUE_FLAG_IS_BRANCH != 0 {
                let sub_node_vcn: u64 =
                    match self.read_index_branch_value(data, index_value_offset, value_data_size) {
                        Ok(index_branch_value) => index_branch_value,
                        Err(mut error) => {
                            keramics_core::error_trace_add_frame!(
                                error,
                                "Unable to read index branch value"
                            );
                            return Err(error);
                        }
                    };
                // TODO: skip if sub node is not allocated.

                let index_entry: NtfsIndexEntry = match self
                    .index
                    .get_entry_at_cluster_block(data_stream, sub_node_vcn)
                {
                    Ok(index_entry) => index_entry,
                    Err(mut error) => {
                        keramics_core::error_trace_add_frame!(
                            error,
                            "Unable to retrieve index entry"
                        );
                        return Err(error);
                    }
                };
                match self.get_directory_entries_from_node(
                    &index_entry.data,
                    24,
                    data_stream,
                    entries,
                ) {
                    Ok(_) => {}
                    Err(mut error) => {
                        keramics_core::error_trace_add_frame!(
                            error,
                            "Unable to retrieve directory entries from sub node"
                        );
                        return Err(error);
                    }
                }
            } else if self.mediator.debug_output && value_data_size > 0 {
                let value_data_end_offset: usize = index_value_offset + value_data_size;

                self.mediator.debug_print(format!(
                    "NtfsDirectoryIndexLeafValueData data of size: {} at offset: {} (0x{:08x})\n",
                    value_data_size, index_value_offset, index_value_offset,
                ));
                self.mediator
                    .debug_print_data(&data[index_value_offset..value_data_end_offset], true);
            }
            if index_value.flags & NTFS_INDEX_VALUE_FLAG_IS_LAST != 0 {
                break;
            }
            let file_name: NtfsFileName =
                match self.read_index_key(data, key_data_offset, key_data_size) {
                    Ok(index_key) => index_key,
                    Err(mut error) => {
                        keramics_core::error_trace_add_frame!(error, "Unable to read index key");
                        return Err(error);
                    }
                };
            match entries.add(index_value.file_reference, file_name) {
                Ok(_) => {}
                Err(mut error) => {
                    keramics_core::error_trace_add_frame!(error, "Unable to add directory entry");
                    return Err(error);
                }
            }
            index_value_offset += value_data_size;

            let alignment_padding: usize = index_value_offset % 8;
            if alignment_padding > 0 {
                // TODO: debug print 8-byte alignment padding.

                index_value_offset += 8 - alignment_padding;
            }
        }
        Ok(())
    }

    /// Reads an index branch value.
    fn read_index_branch_value(
        &self,
        data: &[u8],
        index_value_offset: usize,
        value_data_size: usize,
    ) -> Result<u64, ErrorTrace> {
        let index_value_end_offset: usize = index_value_offset + value_data_size;

        if self.mediator.debug_output {
            self.mediator.debug_print(format!(
                "NtfsDirectoryIndexBranchValueData data of size: {} at offset: {} (0x{:08x})\n",
                value_data_size, index_value_offset, index_value_offset,
            ));
            self.mediator
                .debug_print_data(&data[index_value_offset..index_value_end_offset], true);
        }
        if value_data_size < 8 {
            return Err(keramics_core::error_trace_new!(format!(
                "Invalid index branch value data size: {} value out of bounds",
                value_data_size,
            )));
        }
        let sub_node_vcn: u64 = bytes_to_u64_le!(data, index_value_end_offset - 8);

        Ok(sub_node_vcn)
    }

    /// Reads an index key.
    fn read_index_key(
        &self,
        data: &[u8],
        key_data_offset: usize,
        key_data_size: usize,
    ) -> Result<NtfsFileName, ErrorTrace> {
        let key_data_end_offset: usize = key_data_offset + key_data_size;

        if self.mediator.debug_output {
            self.mediator.debug_print(format!(
                "NtfsDirectoryIndexValueKey data of size: {} at offset: {} (0x{:08x})\n",
                key_data_size, key_data_offset, key_data_offset,
            ));
            self.mediator
                .debug_print_data(&data[key_data_offset..key_data_end_offset], true);
        }
        if self.mediator.debug_output {
            self.mediator.debug_print(NtfsFileName::debug_read_data(
                &data[key_data_offset..key_data_end_offset],
            ));
        }
        let mut file_name: NtfsFileName = NtfsFileName::new();

        match file_name.read_data(&data[key_data_offset..key_data_end_offset]) {
            Ok(_) => {}
            Err(mut error) => {
                keramics_core::error_trace_add_frame!(error, "Unable to read file name");
                return Err(error);
            }
        }
        Ok(file_name)
    }

    /// Reads an index node header.
    fn read_index_node_header(
        &self,
        data: &[u8],
        index_node_offset: usize,
    ) -> Result<(usize, usize), ErrorTrace> {
        if self.mediator.debug_output {
            self.mediator
                .debug_print(NtfsIndexNodeHeader::debug_read_data(
                    &data[index_node_offset..],
                ));
        }
        let mut index_node_header: NtfsIndexNodeHeader = NtfsIndexNodeHeader::new();

        match index_node_header.read_data(&data[index_node_offset..]) {
            Ok(_) => {}
            Err(mut error) => {
                keramics_core::error_trace_add_frame!(error, "Unable to read index node header");
                return Err(error);
            }
        }
        let index_node_size: usize = index_node_header.size as usize;

        if index_node_size > data.len() {
            return Err(keramics_core::error_trace_new!(format!(
                "Invalid index node size: {} value out of bounds",
                index_node_header.size
            )));
        }
        // The index values offset is relative to the start of the index node header.
        let index_values_offset: usize = index_node_header.index_values_offset as usize;

        if index_values_offset < 16 || index_values_offset >= index_node_size {
            return Err(keramics_core::error_trace_new!(format!(
                "Invalid index values offset: {} value out of bounds",
                index_node_header.index_values_offset
            )));
        }
        Ok((index_node_size, index_values_offset))
    }

    /// Reads an index value.
    fn read_index_value(
        &self,
        data: &[u8],
        index_value_offset: usize,
        index_values_end_offset: usize,
    ) -> Result<NtfsIndexValue, ErrorTrace> {
        let index_value_end_offset: usize = index_value_offset + 16;

        if index_value_end_offset > index_values_end_offset {
            return Err(keramics_core::error_trace_new!(
                "Invalid index value offset value out of bounds"
            ));
        }
        if self.mediator.debug_output {
            self.mediator.debug_print(format!(
                "NtfsIndexValue data of size: 16 at offset: {} (0x{:08x})\n",
                index_value_offset, index_value_offset,
            ));
            self.mediator
                .debug_print_data(&data[index_value_offset..index_value_end_offset], true);

            self.mediator.debug_print(NtfsIndexValue::debug_read_data(
                &data[index_value_offset..index_value_end_offset],
            ));
        }
        let mut index_value: NtfsIndexValue = NtfsIndexValue::new();

        match index_value.read_data(&data[index_value_offset..]) {
            Ok(_) => {}
            Err(mut error) => {
                keramics_core::error_trace_add_frame!(error, "Unable to read index value");
                return Err(error);
            }
        }
        let value_data_size: usize = index_value.size as usize;

        if value_data_size > data.len() - index_value_offset {
            return Err(keramics_core::error_trace_new!(format!(
                "Invalid index value size: {} value out of bounds",
                index_value.size,
            )));
        }
        Ok(index_value)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use keramics_core::open_fake_data_stream;
    use keramics_types::constants::UCS2_CASE_MAPPINGS;

    // TODO: add tests for initialize
    // TODO: add tests for get_directory_entry_by_name
    // TODO: add tests for read_directory_entries

    #[test]
    fn test_get_directory_entries_from_node() -> Result<(), ErrorTrace> {
        let mut test_data: Vec<u8> = vec![
            0x49, 0x4e, 0x44, 0x58, 0x28, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
            0xa0, 0x05, 0x00, 0x00, 0xe8, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00,
            0xdb, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x04, 0x00, 0x68, 0x00, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b,
            0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01,
            0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x08, 0x03, 0x24, 0x00, 0x41, 0x00, 0x74, 0x00, 0x74, 0x00,
            0x72, 0x00, 0x44, 0x00, 0x65, 0x00, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x68, 0x00, 0x52, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x5b, 0x3c, 0xa6,
            0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b,
            0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x03, 0x24, 0x00,
            0x42, 0x00, 0x61, 0x00, 0x64, 0x00, 0x43, 0x00, 0x6c, 0x00, 0x75, 0x00, 0x73, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
            0x60, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x05, 0x00, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6,
            0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b,
            0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x07, 0x03, 0x24, 0x00, 0x42, 0x00, 0x69, 0x00, 0x74, 0x00, 0x6d, 0x00,
            0x61, 0x00, 0x70, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x60, 0x00,
            0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
            0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e,
            0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6,
            0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x05, 0x03, 0x24, 0x00, 0x42, 0x00, 0x6f, 0x00, 0x6f, 0x00, 0x74, 0x00, 0x69, 0x00,
            0x6c, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x60, 0x00, 0x50, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x5b,
            0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01,
            0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0x0b, 0x00, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e,
            0xdb, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x07, 0x03,
            0x24, 0x00, 0x45, 0x00, 0x78, 0x00, 0x74, 0x00, 0x65, 0x00, 0x6e, 0x00, 0x64, 0x00,
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x68, 0x00, 0x52, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x5b, 0x3c, 0xa6,
            0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b,
            0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01,
            0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x03, 0x24, 0x00,
            0x4c, 0x00, 0x6f, 0x00, 0x67, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6c, 0x00, 0x65, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x60, 0x00, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x05, 0x00, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6,
            0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b,
            0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x04, 0x03, 0x24, 0x00, 0x4d, 0x00, 0x46, 0x00, 0x54, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x68, 0x00,
            0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
            0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e,
            0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6,
            0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x08, 0x03, 0x24, 0x00, 0x4d, 0x00, 0x46, 0x00, 0x54, 0x00, 0x4d, 0x00, 0x69, 0x00,
            0x72, 0x00, 0x72, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x09, 0x00, 0x60, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01,
            0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e,
            0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
            0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x07, 0x03, 0x24, 0x00, 0x53, 0x00, 0x65, 0x00,
            0x63, 0x00, 0x75, 0x00, 0x72, 0x00, 0x65, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x0a, 0x00, 0x60, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b,
            0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01,
            0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
            0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x07, 0x03, 0x24, 0x00, 0x55, 0x00, 0x70, 0x00, 0x43, 0x00,
            0x61, 0x00, 0x73, 0x00, 0x65, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
            0x60, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x05, 0x00, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6,
            0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b,
            0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x07, 0x03, 0x24, 0x00, 0x56, 0x00, 0x6f, 0x00, 0x6c, 0x00, 0x75, 0x00,
            0x6d, 0x00, 0x65, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x58, 0x00,
            0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
            0x00, 0x5b, 0x3c, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x50, 0x1d, 0x89, 0xa6, 0x8b, 0x5e,
            0xdb, 0x01, 0x50, 0x1d, 0x89, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x5b, 0x3c, 0xa6,
            0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
            0x01, 0x03, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x68, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x98, 0xfe, 0x88, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x40, 0x01,
            0x89, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x40, 0x01, 0x89, 0xa6, 0x8b, 0x5e, 0xdb, 0x01,
            0x40, 0x01, 0x89, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x65, 0x00, 0x6d, 0x00, 0x70, 0x00, 0x74, 0x00,
            0x79, 0x00, 0x66, 0x00, 0x69, 0x00, 0x6c, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x68, 0x00, 0x52, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x10, 0x1d, 0x89, 0xa6,
            0x8b, 0x5e, 0xdb, 0x01, 0x74, 0x64, 0x89, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x74, 0x64,
            0x89, 0xa6, 0x8b, 0x5e, 0xdb, 0x01, 0x10, 0x1d, 0x89, 0xa6, 0x8b, 0x5e, 0xdb, 0x01,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x74, 0x00,
            0x65, 0x00, 0x73, 0x00, 0x74, 0x00, 0x64, 0x00, 0x69, 0x00, 0x72, 0x00, 0x31, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00,
        ];

        let mut index_entry = NtfsIndexEntry::new();
        index_entry.read_data(&mut test_data)?;

        let case_folding_mappings: Arc<HashMap<u16, u16>> = Arc::new(
            UCS2_CASE_MAPPINGS
                .into_iter()
                .collect::<HashMap<u16, u16>>(),
        );
        let test_struct = NtfsDirectoryIndex::new(4096, &case_folding_mappings);
        let data_stream: DataStreamReference = open_fake_data_stream(&[]);

        let mut entries: NtfsDirectoryEntries = NtfsDirectoryEntries::new();
        test_struct.get_directory_entries_from_node(&test_data, 24, &data_stream, &mut entries)?;

        assert_eq!(entries.get_number_of_entries(), 13);

        Ok(())
    }

    // TODO: add tests for read_index_branch_value
    // TODO: add tests for read_index_key
    // TODO: add tests for read_index_node_header
    // TODO: add tests for read_index_value
}
