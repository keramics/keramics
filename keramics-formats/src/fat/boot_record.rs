/* Copyright 2024-2025 Joachim Metz <joachim.metz@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may
 * obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

use std::io::SeekFrom;

use keramics_core::mediator::{Mediator, MediatorReference};
use keramics_core::{DataStreamReference, ErrorTrace};
use keramics_types::ByteString;

use super::boot_record_fat12::Fat12BootRecord;
use super::boot_record_fat32::Fat32BootRecord;

/// File Allocation Table (FAT) boot record.
pub struct FatBootRecord {
    /// Mediator.
    mediator: MediatorReference,

    /// Bytes per sector.
    pub bytes_per_sector: u16,

    /// Sectors per cluster block.
    pub sectors_per_cluster_block: u8,

    /// Number of reserved sectors.
    pub number_of_reserved_sectors: u16,

    /// Number of allocation tables.
    pub number_of_allocation_tables: u8,

    /// Number of root directory entries.
    pub number_of_root_directory_entries: u16,

    /// File allocation table size.
    pub allocation_table_size: u32,

    /// Number of sectors.
    pub number_of_sectors: u32,

    /// Root directory cluster block number.
    pub root_directory_cluster_block_number: u32,

    /// Volume serial number.
    pub volume_serial_number: u32,

    /// Volume label.
    pub volume_label: ByteString,
}

impl FatBootRecord {
    /// Creates a new boot record.
    pub fn new() -> Self {
        Self {
            mediator: Mediator::current(),
            bytes_per_sector: 0,
            sectors_per_cluster_block: 0,
            number_of_reserved_sectors: 0,
            number_of_sectors: 0,
            number_of_root_directory_entries: 0,
            number_of_allocation_tables: 0,
            allocation_table_size: 0,
            root_directory_cluster_block_number: 0,
            volume_serial_number: 0,
            volume_label: ByteString::new(),
        }
    }

    /// Reads the boot record a specific position in a data stream.
    pub fn read_at_position(
        &mut self,
        data_stream: &DataStreamReference,
        position: SeekFrom,
    ) -> Result<(), ErrorTrace> {
        let mut data: Vec<u8> = vec![0; 512];

        let offset: u64 =
            keramics_core::data_stream_read_exact_at_position!(data_stream, &mut data, position);
        if self.mediator.debug_output {
            self.mediator.debug_print(format!(
                "FatBootRecord data of size: 512 at offset: {} (0x{:08x})\n",
                offset, offset
            ));
            self.mediator.debug_print_data(&data, true);
        }
        if data[17..21] == [0; 4] && data[22..24] == [0; 2] {
            if self.mediator.debug_output {
                self.mediator
                    .debug_print(Fat32BootRecord::debug_read_data(&data));
            }
            match Fat32BootRecord::read_data(self, &data) {
                Ok(_) => {}
                Err(mut error) => {
                    keramics_core::error_trace_add_frame!(
                        error,
                        "Unable to read FAT-32 boot record"
                    );
                    return Err(error);
                }
            }
        } else {
            if self.mediator.debug_output {
                self.mediator
                    .debug_print(Fat12BootRecord::debug_read_data(&data));
            }
            match Fat12BootRecord::read_data(self, &data) {
                Ok(_) => {}
                Err(mut error) => {
                    keramics_core::error_trace_add_frame!(
                        error,
                        "Unable to read FAT-12 or FAT-16 boot record"
                    );
                    return Err(error);
                }
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use keramics_core::open_fake_data_stream;

    fn get_test_data_fat12() -> Vec<u8> {
        return vec![
            0xeb, 0x3c, 0x90, 0x6d, 0x6b, 0x66, 0x73, 0x2e, 0x66, 0x61, 0x74, 0x00, 0x02, 0x04,
            0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x20, 0xf8, 0x06, 0x00, 0x20, 0x00, 0x02, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x29, 0x5b, 0x0d, 0xf3,
            0x56, 0x46, 0x41, 0x54, 0x31, 0x32, 0x5f, 0x54, 0x45, 0x53, 0x54, 0x20, 0x46, 0x41,
            0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x0e, 0x1f, 0xbe, 0x5b, 0x7c, 0xac, 0x22, 0xc0,
            0x74, 0x0b, 0x56, 0xb4, 0x0e, 0xbb, 0x07, 0x00, 0xcd, 0x10, 0x5e, 0xeb, 0xf0, 0x32,
            0xe4, 0xcd, 0x16, 0xcd, 0x19, 0xeb, 0xfe, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73,
            0x20, 0x6e, 0x6f, 0x74, 0x20, 0x61, 0x20, 0x62, 0x6f, 0x6f, 0x74, 0x61, 0x62, 0x6c,
            0x65, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x2e, 0x20, 0x20, 0x50, 0x6c, 0x65, 0x61, 0x73,
            0x65, 0x20, 0x69, 0x6e, 0x73, 0x65, 0x72, 0x74, 0x20, 0x61, 0x20, 0x62, 0x6f, 0x6f,
            0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x66, 0x6c, 0x6f, 0x70, 0x70, 0x79, 0x20, 0x61,
            0x6e, 0x64, 0x0d, 0x0a, 0x70, 0x72, 0x65, 0x73, 0x73, 0x20, 0x61, 0x6e, 0x79, 0x20,
            0x6b, 0x65, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x72, 0x79, 0x20, 0x61, 0x67, 0x61,
            0x69, 0x6e, 0x20, 0x2e, 0x2e, 0x2e, 0x20, 0x0d, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa,
        ];
    }

    #[test]
    fn test_read_at_position_fat12() -> Result<(), ErrorTrace> {
        let test_data: Vec<u8> = get_test_data_fat12();
        let data_stream: DataStreamReference = open_fake_data_stream(&test_data);

        let mut test_struct = FatBootRecord::new();
        test_struct.read_at_position(&data_stream, SeekFrom::Start(0))?;

        assert_eq!(test_struct.bytes_per_sector, 512);
        assert_eq!(test_struct.sectors_per_cluster_block, 4);
        assert_eq!(test_struct.number_of_reserved_sectors, 1);
        assert_eq!(test_struct.number_of_allocation_tables, 2);
        assert_eq!(test_struct.number_of_root_directory_entries, 512);
        assert_eq!(test_struct.allocation_table_size, 6);
        assert_eq!(test_struct.number_of_sectors, 8192);
        assert_eq!(test_struct.volume_serial_number, 0x56f30d5b);
        assert_eq!(test_struct.volume_label, ByteString::from("FAT12_TEST"));

        Ok(())
    }
}
